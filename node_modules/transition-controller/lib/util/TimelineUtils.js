"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.createTimeline = createTimeline;
exports.killAndClearTimeline = killAndClearTimeline;
exports.clearTimeline = clearTimeline;
exports.cloneTimeline = cloneTimeline;

var _gsap = require("gsap");

var _TransitionDirection = _interopRequireDefault(require("../enum/TransitionDirection"));

/**
 * The create timeline method creates a new TimelineLite or TimelineMax timeline
 *
 * @param {ICreateTimelineOptions} options
 * @returns {TimelineMax}
 */
function createTimeline(options) {
  var forward = true;
  var lastTime = 0;
  var timeline = new _gsap.TimelineMax({
    paused: true,
    onUpdate: function onUpdate() {
      // GreenSock does not support onReverseStart on a timeline therefore we have this little method
      // chat checks for the direction and if it's changed we handle it as if it's a reverse start
      var newTime = timeline.time();

      if (forward && newTime < lastTime || !forward && newTime > lastTime) {
        forward = !forward;

        if (!forward && options.onReverseStart !== null) {
          options.onReverseStart();
        }
      }

      lastTime = newTime;
    },
    onStart: function onStart() {
      // Reset the last time when we restart the timeline
      lastTime = 0; // Trigger the callback if needed

      if (options.onStart) options.onStart();
    },
    onComplete: options.onComplete !== null ? options.onComplete : null,
    onReverseComplete: function onReverseComplete() {
      // When the transition out is completed we have to reset the last
      // time otherwise the transition will no longer work.
      lastTime = 0; // Trigger the callback if needed

      if (options.onReverseComplete !== null) options.onReverseComplete();
    }
  });
  return timeline;
}
/**
 * Sometimes you want to fully kill a timeline and strip all the added
 * inline styles. This method accepts a timeline and it will remove all
 * the inline styling and kill the timeline instance.
 *
 * @param {TimelineMax} timeline
 * @returns {void}
 */


function killAndClearTimeline(timeline) {
  clearTimeline(timeline);
  timeline.kill();
}
/**
 * Sometimes you do not want to kill the timeline but only kill the inline
 * styling. This method accepts a timeline and it will remove all the inline styling.
 *
 * @param {TimelineMax} timeline
 * @returns {void}
 */


function clearTimeline(timeline) {
  timeline.getChildren().forEach(function (target) {
    if (target.target) {
      // Note: When resetting a timeline clearing just the css properties does not clear the properties like autoAlpha or scale
      _gsap.TweenLite.set(target.target, {
        clearProps: 'all'
      });
    } else {
      clearTimeline(target);
    }
  });
  timeline.clear();
}
/**
 *  When you want to clone a timeline (for example when you want to nest it within
 *  another timeline but also still want to be able to play the original timeline
 *  this is the method you are looking for. It will create a new TimeLineLite or
 *  TimelineMax and re-add all the original animations and event listeners.
 *
 * @param {gsap.gsap.TimelineMax} source
 * @param {TransitionDirection} direction
 * @param {boolean} useTimelineMax
 * @returns {TimelineMax}
 */


function cloneTimeline(source, direction) {
  var children = source.getChildren(false);
  var timeline = new _gsap.TimelineMax(source.vars);

  var parseChild = function parseChild(child, timeline) {
    if (child.getChildren) {
      var _children = child.getChildren(false);

      var subTimeline = new _gsap.TimelineMax(child.vars); // Parse the child animations

      _children.forEach(function (child) {
        return parseChild(child, subTimeline);
      }); // Add the timeline to the parent timeline


      timeline.add(subTimeline.restart(), child._startTime);
    } else {
      if (child.vars.startAt) {
        if (direction === _TransitionDirection.default.OUT) {
          throw new Error('Do not use fromTo when nesting transitionOutTimelines, use to instead!');
        }

        var from = JSON.parse(JSON.stringify(child.vars.startAt)); // Clone the vars

        var to = child.vars; // Create the fromTo tween

        timeline.fromTo(child.target, child._duration, from, to, child._startTime);
      } else {
        if (child.vars.runBackwards) {
          // When nesting timelines and the user defines a root timeline with a from the clone will
          // have incorrect styling because the base styling is off!
          // timeline.from(child.target, child._duration, child.vars, child._startTime);
          throw new Error('Do not use from while nesting transitionInTimelines, use fromTo instead!');
        } else {
          timeline.to(child.target, child._duration, child.vars, child._startTime);
        }
      }
    }
  };

  children.forEach(function (child) {
    return parseChild(child, timeline);
  });
  return timeline;
}