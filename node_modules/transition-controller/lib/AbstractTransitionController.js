"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _gsap = require("gsap");

var _sengEvent = _interopRequireDefault(require("seng-event"));

var _TransitionEvent = _interopRequireDefault(require("./event/TransitionEvent"));

var _TimelineUtils = require("./util/TimelineUtils");

var _TransitionDirection = _interopRequireDefault(require("./enum/TransitionDirection"));

var _TimelineType = _interopRequireDefault(require("./enum/TimelineType"));

/**
 * ### AbstractTransitionController
 * The AbstractTransitionController is the main class of the module. See the sub-pages for detailed information about the properties and methods.
 *
 * @param T This param defines the type of the parent controller, this is of course framework specific.
 */
var AbstractTransitionController =
/*#__PURE__*/
function (_EventDispatcher) {
  (0, _inheritsLoose2.default)(AbstractTransitionController, _EventDispatcher);

  /**
   * @private
   * @static counter
   * @description a namespace counter used for unique naming of components
   * @type {number}
   */

  /**
   * The parentController gives you access to the class that constructed the
   * transition controller. You might need this if you want to access elements
   * from the parentController. For example in a Vue.js project you might want
   * to access the **$refs** of you Vue.js component to setup your animations.
   *
   * @public
   */

  /**
   * The isHidden property gives you the current transition state of the
   * component. A component is either hidden or not.
   *
   * @public
   */

  /**
   * The loopingAnimationStarted property gives you the current looping
   * transition state of the component a looping animation is either running or not.
   *
   * @public
   */

  /**
   * The transitionInTimeline property is the timeline that is used for the in animation
   * of the component.
   *
   * @public
   */

  /**
   * The transitionOutTimeline property is the timeline that is used for the out
   * animation of the component.
   *
   * @public
   */

  /**
   * The loopingAnimationTimeline property is the timeline that is used for the looping
   * animations inside of a component. The timeline configuration is setup to loop until pause is called.
   *
   * @public
   */

  /**
   * The resolve method used for resolving the transition in promise.
   *
   * @private
   */

  /**
   * The resolve method used for resolving the transition out promise.
   *
   * @private
   */

  /**
   * The reject method used for rejecting the transition in promise.
   *
   * @private
   */

  /**
   * The resolve method used for rejecting the transition out promise.
   *
   * @private
   */

  /**
   * The transition promise is used so we can wait for the transition in to be completed.
   *
   * @private
   */

  /**
   * The transition promise is used so we can wait for the transition out to be completed.
   *
   * @private
   */

  /**
   * The options that were provided when constructing the class are stored on this property
   *
   * @private
   */

  /**
   * The constructor initiates the class, it merges the default options with the
   * provided options and creates the transition timelines.
   *
   * **Note:** Keep in mind that the moment the transition controller is constructed
   * it also calls the init method that triggers the methods to setup the timelines.
   * So always cconstruct the transition controller after your component is ready.
   *
   * @param {T} parent The reference to the parent instance
   * @param {IAbstractTransitionControllerOptions} options The configuration object for the transition controller
   */
  function AbstractTransitionController(parent, options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _EventDispatcher.call(this) || this; // Store the parent reference

    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "parentController", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "isHidden", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: true
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "loopingAnimationStarted", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: false
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "transitionInTimeline", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "transitionOutTimeline", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "loopingAnimationTimeline", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "transitionInResolveMethod", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "transitionOutResolveMethod", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "transitionInRejectMethod", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "transitionOutRejectMethod", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "transitionInPromise", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "_transitionOutPromise", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "options", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: {
        name: "unnamed-component-" + AbstractTransitionController.counter++,
        transitionController: 'transitionController',
        debug: false,
        transitionInId: null,
        transitionOutId: null,
        loopId: null
      }
    });
    _this.parentController = parent; // Merge the options

    Object.assign(_this.options, options); // Create the timelines

    _this.createTransitionTimelines(); // Initialize the transition controller


    _this.init();

    return _this;
  }
  /**
   * The transitionIn method restarts the transitionInTimeline and returns
   * a promise to let you know that is is done with the animation. By default the
   * transition in will wait for any old transitionOut that is still running. If
   * you want to force your transition in and kill any running transitionOut animations
   * you should set the forceTransition flag to true when calling the transitionIn method.
   *
   * @public
   * @param { boolean } forceTransition
   * @returns { Promise<any> }
   */


  var _proto = AbstractTransitionController.prototype;

  _proto.transitionIn = function transitionIn(forceTransition) {
    var _this2 = this;

    if (forceTransition === void 0) {
      forceTransition = false;
    }

    var oldTransitionPromise = Promise.resolve();
    /**
     * Check if we already have a transition out going on, if so we finish it right away! and trigger a
     * transition complete.
     */

    if (this._transitionOutPromise !== null) {
      if (forceTransition) {
        if (this.transitionOutTimeline.getChildren().length > 0) {
          this.transitionOutTimeline.kill();
        } else {
          this.transitionInTimeline.kill();
        }

        this.handleTransitionComplete(_TransitionDirection.default.OUT);

        if (this.options.debug) {
          console.info(this.options.name + " Interrupted the transition out!");
        }
      } else {
        oldTransitionPromise = this._transitionOutPromise;
      }
    }

    return oldTransitionPromise.then(function () {
      // Component is already transitioning out
      if (_this2.transitionInPromise !== null && forceTransition) {
        if (_this2.options.debug) {
          console.warn("[TransitionController][" + _this2.options.name + "] Already transitioning in, so rejecting the original \n          transitionIn promise to clear any queued animations. We finish the current animation and return a resolved \n          promise right away");
        } // TODO: should the forced out wait for the original animation to be completed??


        _this2.transitionInRejectMethod();

        _this2.transitionInPromise = null;
      } // Make sure the transitionOut is paused in case we clicked the transitionIn while
      // the transitionOut was not finished yet.


      _this2.transitionOutTimeline.paused(true); // Only allow the transition in if the element is hidden


      if (_this2.transitionInPromise === null && _this2.isHidden) {
        _this2.transitionInPromise = new Promise(function (resolve) {
          if (_this2.transitionInTimeline.getChildren().length === 0) {
            if (_this2.options.debug) {
              console.info(_this2.options.name + ": This block has no transition in timeline");
            } // Manually trigger handleTransitionStart because the timeline is empty.


            _this2.handleTransitionStart(_TransitionDirection.default.IN);

            setTimeout(function () {
              // Manually trigger handleTransitionComplete because the timeline is empty
              _this2.handleTransitionComplete(_TransitionDirection.default.IN); // Add a next tick between the events otherwise the events happen simultaneously.


              resolve();
            }, 0);
          } else {
            // Remove the paused state from transitionIn Timeline
            _this2.transitionInTimeline.paused(false);

            _this2.transitionInResolveMethod = resolve;
            _this2.transitionInRejectMethod = resolve;

            _this2.transitionInTimeline.restart();
          }
        });
      }

      if (_this2.transitionInPromise === null) {
        if (_this2.options.debug) {
          console.warn("[TransitionController][" + _this2.options.name + "] Transition in triggered when it's already \n          visible, so we will do nothing and return a resolved promise!");
        }

        return Promise.resolve();
      }

      return _this2.transitionInPromise;
    });
  };
  /**
   /**
   * The transitionOut method will look if the transitionOutTimeline has any
   * animations added to it. If no animations were added it will reverse the
   * transitionInTimeline. Otherwise it will restart the transitionOutTimeline.
   *
   * @public
   * @param {boolean} forceTransition Forcing a transition means that the old transition out will be stopped!
   * @param {string} id This is the id of the transition out timeline that you want to trigger
   * @param {boolean} reset This means that the transition out timeline will be re-initialized.
   * @returns {Promise<void>}
   */


  _proto.transitionOut = function transitionOut(forceTransition, id, reset) {
    var _this3 = this;

    if (forceTransition === void 0) {
      forceTransition = false;
    }

    if (id === void 0) {
      id = this.options.transitionOutId;
    }

    if (reset === void 0) {
      reset = false;
    }

    var oldTransitionPromise = Promise.resolve(); // The transition out timeline might not be created yet, so initialize it runtime.

    this.setupTimeline(_TimelineType.default.OUT, reset, id);
    /**
     * Check if we already have a transition out going on, if so we finish it right away! and trigger a
     * transition complete.
     */

    if (this.transitionInPromise !== null) {
      if (forceTransition) {
        this.transitionInTimeline.kill();
        this.handleTransitionComplete(_TransitionDirection.default.IN);

        if (this.options.debug) {
          console.warn(this.options.name + " Interrupted the transition in!");
        }
      } else {
        oldTransitionPromise = this.transitionInPromise;
      }
    }

    return oldTransitionPromise.then(function () {
      // Component is already transitioning out
      if (_this3._transitionOutPromise !== null && forceTransition) {
        if (_this3.options.debug) {
          console.warn("[TransitionController][" + _this3.options.name + "] Already transitioning out, so rejecting the \n          original transitionOut promise to clear any queued animations. We finish the current animation and return \n          a resolved promise right away");
        } // TODO: should the forced out wait for the original animation to be completed??


        _this3.transitionOutRejectMethod();

        _this3._transitionOutPromise = null;
      } // Only allow the transition out if the element is not hidden


      if (_this3._transitionOutPromise === null && !_this3.isHidden) {
        _this3.isHidden = true; // If we do have a transitionOut make sure the transitionIn is paused in case we clicked the
        // transitionOut while the transitionIn was not finished yet.

        if (_this3.transitionOutTimeline.getChildren().length > 0) {
          _this3.transitionOutTimeline.paused(false);

          _this3.transitionInTimeline.paused(true);
        } else {
          // We don't have a transitionOutTimeline, so we are reversing it, therefore removing the paused state.
          _this3.transitionInTimeline.paused(false);
        }

        _this3._transitionOutPromise = new Promise(function (resolve, reject) {
          _this3.transitionOutResolveMethod = resolve;
          _this3.transitionOutRejectMethod = reject;

          if (_this3.transitionOutTimeline.getChildren().length > 0) {
            _this3.transitionOutTimeline.restart();
          } else {
            _this3.transitionInTimeline.reverse();
          }
        });
      }

      if (_this3._transitionOutPromise === null) {
        if (_this3.options.debug) {
          console.warn("[TransitionController][" + _this3.options.name + "] Transition out triggered when it's already hidden, \n          so we will do nothing and return a resolved promise!");
        } // Already hidden, so resolve it right away


        return Promise.resolve();
      }

      return _this3._transitionOutPromise;
    });
  };
  /**
   * This method is pretty straightforward will start the loopingAnimationTimeline.
   *
   * @param {string} id This is the id of the timeline that you want to start
   * @param {boolean} reset This means that the timeline will be re-initialized.
   */


  _proto.startLoopingAnimation = function startLoopingAnimation(id, reset) {
    if (id === void 0) {
      id = this.options.loopId;
    }

    if (reset === void 0) {
      reset = true;
    }

    this.setupTimeline(_TimelineType.default.LOOPING, reset, id);
    this.loopingAnimationTimeline.play();
    this.loopingAnimationStarted = true;
  };
  /**
   * This method is pretty straightforward will stop the loopingAnimationTimeline.
   *
   * @public
   */


  _proto.stopLoopingAnimation = function stopLoopingAnimation() {
    this.loopingAnimationTimeline.pause();
    this.loopingAnimationStarted = false;
  };
  /**
   * When nesting transition components you might want to nest the timelines
   * as well, this makes it easier to time all the component transitions. Keep
   * in mind that the getTimeline method returns a clone of the original timeline.
   *
   * @public
   * @param {string | HTMLElement | T} component The selector for the component that you want the timeline for
   * @param {TransitionDirection} direction The direction of the timeline that you want
   * @param {boolean} reset This flag determines if we reset the existing timeline or re-create it from scratch
   * @param {boolean} id This is the id of the timeline that we are requesting
   * @returns { Animation } The timeline that is retrieved
   */


  _proto.getTimeline = function getTimeline(component, direction, reset, id) {
    if (direction === void 0) {
      direction = _TransitionDirection.default.IN;
    }

    if (reset === void 0) {
      reset = false;
    }

    var componentInstance = this.getComponent(component);
    var timelineInstance = this.getTimelineInstance(componentInstance, direction, reset, id);
    return (0, _TimelineUtils.cloneTimeline)(timelineInstance, direction).restart();
  };
  /**
   * @public
   * @param {string | HTMLElement | T} component The selector for the component that you want to get the timeline for
   * @param {TransitionDirection} direction The direction that you want to check for
   * @param {boolean} reset This flag determines if we reset the existing timeline or re-create it from scratch
   * @param {boolean} id This is the id of the timeline that we are requesting
   * @returns {number} The duration of the timeline
   */


  _proto.getTimelineDurationForComponent = function getTimelineDurationForComponent(component, direction, reset, id) {
    if (direction === void 0) {
      direction = _TransitionDirection.default.IN;
    }

    if (reset === void 0) {
      reset = false;
    }

    return this.getTimelineInstance(this.getComponent(component), direction, reset, id).duration();
  };
  /**
   * Setup timeline is a wrapper method that calls the correct setup methods and clears any old timelines if necessary
   *
   * @public
   * @param {Timeline} type This is the type of timeline that will be initialized.
   * @param {boolean} reset This means the timeline will be cleared before initializing
   * @param {string} id This is the id of the timeline that should be initialized.
   */


  _proto.setupTimeline = function setupTimeline(type, reset, id) {
    if (reset === void 0) {
      reset = true;
    }

    var timeline;
    var transitionId;
    var setupMethod;

    switch (type) {
      case _TimelineType.default.IN:
        timeline = this.transitionInTimeline;
        transitionId = id === void 0 ? this.options.transitionInId : id;
        setupMethod = this.setupTransitionInTimeline.bind(this);
        break;

      case _TimelineType.default.OUT:
        timeline = this.transitionOutTimeline;
        transitionId = id === void 0 ? this.options.transitionOutId : id;
        setupMethod = this.setupTransitionOutTimeline.bind(this);
        break;

      case _TimelineType.default.LOOPING:
        timeline = this.loopingAnimationTimeline;
        transitionId = id === void 0 ? this.options.loopId : id;
        setupMethod = this.setupLoopingAnimationTimeline.bind(this);
        break;

      default:
        throw new Error("Unsupported timeline type: " + type);
    }

    if (reset || id !== transitionId) (0, _TimelineUtils.killAndClearTimeline)(timeline);

    if (timeline.getChildren() <= 0) {
      setupMethod(timeline, this.parentController, transitionId);
    } else if (this.options.debug) {
      console.warn("[TransitionController][timeline: " + timeline + " id: " + transitionId + "] Skipping setup method because \n      the timeline already has children!");
    }
  };
  /**
   * This method will be used for setting up the timelines for the component
   *
   * @protected
   */


  _proto.init = function init() {
    this.setupTimeline(_TimelineType.default.IN, true, this.options.transitionInId);
  };
  /**
   * This method is actually set's up the transition out timeline. it should contain all
   * the animations that are required for the transition out to done.
   *
   * @protected
   * @param {TimelineMax} timeline The reference to the transition out timeline
   * @param {T} parent The reference to the parent instance
   * @param {string} id The id of the transition out timeline that should be initialized
   * @param {boolean} reset When this flag is set to true the old timeline will be cleared before calling the method
   */


  /**
   * Method that finds the correct timeline instance on the provided parent controller.
   *
   * @private
   * @param {T} component This is the component instance that will will get the timeline for
   * @param {TransitionDirection} direction This is the direction of the timeline.
   * @param {boolean} reset This flag determines if we reset the existing timeline or re-create it from scratch
   * @param {boolean} id This is the id of the timeline that we are requesting
   * @returns {TimelineMax} This is the timeline instance that you requested
   */
  _proto.getTimelineInstance = function getTimelineInstance(component, direction, reset, id) {
    if (direction === void 0) {
      direction = _TransitionDirection.default.IN;
    }

    if (reset === void 0) {
      reset = false;
    }

    var transitionController = component[this.options.transitionController];
    var timeline;

    if (direction === _TransitionDirection.default.OUT) {
      transitionController.setupTimeline(_TimelineType.default.OUT, reset, id);
      timeline = transitionController.transitionOutTimeline;
    } else {
      timeline = transitionController.transitionInTimeline;
    }

    return timeline;
  };
  /**
   * This method creates the actual empty GSAP timelines.
   *
   * @private
   */


  _proto.createTransitionTimelines = function createTransitionTimelines() {
    var _this4 = this;

    this.transitionInTimeline = (0, _TimelineUtils.createTimeline)({
      onStart: function onStart() {
        return _this4.handleTransitionStart(_TransitionDirection.default.IN);
      },
      onComplete: function onComplete() {
        return _this4.handleTransitionComplete(_TransitionDirection.default.IN);
      },
      onReverseStart: function onReverseStart() {
        return _this4.handleTransitionStart(_TransitionDirection.default.OUT);
      },
      onReverseComplete: function onReverseComplete() {
        return _this4.handleTransitionComplete(_TransitionDirection.default.OUT);
      }
    });
    this.transitionOutTimeline = (0, _TimelineUtils.createTimeline)({
      onStart: function onStart() {
        return _this4.handleTransitionStart(_TransitionDirection.default.OUT);
      },
      onComplete: function onComplete() {
        return _this4.handleTransitionComplete(_TransitionDirection.default.OUT);
      }
    });
    this.loopingAnimationTimeline = new _gsap.TimelineMax({
      paused: true,
      repeat: -1
    });
  };
  /**
   * Method that is triggered when the transition starts. It dispatches the correct
   * event that is linked to the type of transition.
   *
   * @param {TransitionDirection} direction The direction of the timeline that is started
   */


  _proto.handleTransitionStart = function handleTransitionStart(direction) {
    switch (direction) {
      case _TransitionDirection.default.IN:
        if (!this.isDisposed()) {
          this.dispatchEvent(new _TransitionEvent.default(_TransitionEvent.default.TRANSITION_IN_START));
        }

        this.isHidden = false;
        break;

      case _TransitionDirection.default.OUT:
        if (!this.isDisposed()) {
          this.dispatchEvent(new _TransitionEvent.default(_TransitionEvent.default.TRANSITION_OUT_START));
        }

        this.isHidden = true;
        break;

      default: // No default statement

    }
  };
  /**
   * Method that is triggered when the transition completes. It dispatches the correct
   * event that is linked to the type of transition.
   *
   * @private
   * @param { string } direction The direction the transition was completed in.
   */


  _proto.handleTransitionComplete = function handleTransitionComplete(direction) {
    switch (direction) {
      case _TransitionDirection.default.IN:
        this.transitionInPromise = null;

        if (this.transitionInResolveMethod !== null) {
          this.transitionInResolveMethod();
          this.transitionInResolveMethod = null;
        }

        if (!this.isDisposed()) {
          this.dispatchEvent(new _TransitionEvent.default(_TransitionEvent.default.TRANSITION_IN_COMPLETE));
        }

        break;

      case _TransitionDirection.default.OUT:
        {
          this._transitionOutPromise = null;

          if (this.transitionOutResolveMethod !== null) {
            this.transitionOutResolveMethod();
            this.transitionOutResolveMethod = null;
          }

          if (!this.isDisposed()) {
            this.dispatchEvent(new _TransitionEvent.default(_TransitionEvent.default.TRANSITION_OUT_COMPLETE));
          }

          break;
        }
    }
  };
  /**
   * Method that cleans all the timelines and strips out all the resolve methods.
   *
   * @private
   */


  _proto.clean = function clean() {
    this.parentController = null;
    this.isHidden = null;

    if (this.transitionOutTimeline !== null) {
      (0, _TimelineUtils.killAndClearTimeline)(this.transitionOutTimeline);
      this.transitionOutTimeline = null;
    }

    if (this.transitionInTimeline !== null) {
      (0, _TimelineUtils.killAndClearTimeline)(this.transitionInTimeline);
      this.transitionInTimeline = null;
    }

    if (this.loopingAnimationTimeline) {
      (0, _TimelineUtils.killAndClearTimeline)(this.loopingAnimationTimeline);
      this.loopingAnimationTimeline = null;
    }

    this.transitionOutResolveMethod = null;
    this.transitionInResolveMethod = null;
    this._transitionOutPromise = null;
    this.transitionInPromise = null;
  };
  /**
   * Because Vue destructs the VM instance before it removes the DOM node we want to finish the
   * transition out before actually cleaning everything
   *
   * @public
   */


  _proto.dispose = function dispose() {
    if (this._transitionOutPromise !== null && this.transitionOutResolveMethod !== null) {
      this._transitionOutPromise.then(this.clean.bind(this));
    } else {
      this.clean();
    }

    _EventDispatcher.prototype.dispose.call(this);
  };

  return AbstractTransitionController;
}(_sengEvent.default);

exports.default = AbstractTransitionController;
Object.defineProperty(AbstractTransitionController, "counter", {
  configurable: true,
  enumerable: true,
  writable: true,
  value: 0
});