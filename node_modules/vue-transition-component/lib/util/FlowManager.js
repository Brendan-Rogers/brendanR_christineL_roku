"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = exports.FlowManager = void 0;

var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var bowser = _interopRequireWildcard(require("bowser"));

var _sengEvent = _interopRequireDefault(require("seng-event"));

var _FlowType = _interopRequireDefault(require("../enum/FlowType"));

var _FlowEvent = _interopRequireDefault(require("../event/FlowEvent"));

/**
 * ### FlowManager
 * The FlowManager is a singleton that is used to trigger page transitions
 * between pages. It is triggered when Vue.js detects a beforeRouteLeave,
 * passes along the next method and calls it when the transition out of the
 * current page has been completed. It can also be used for hijacking the page
 * flow, this will make sure the new page does not transition in until the
 * release method has been called.
 */
var FlowManager =
/*#__PURE__*/
function (_EventDispatcher) {
  (0, _inheritsLoose2.default)(FlowManager, _EventDispatcher);

  /**
   * This property contains a promise that is the transition out method that
   * is called when we leave the page. When the transition out is done this
   * promise will be resolved and the flow is allowed to continue.
   *
   * @public
   */

  /**
   * This property contains the promise that hijacks the flow. When the flow
   * hijack is released this promise will be released as well and the flow is allowed to continue.
   *
   * @public
   */

  /**
   * This property contains the componentId of the last page/component that was active. The vue-router
   * onLeave method is triggered twice, therefore we store the previous componentId so we can ignore
   * the second time.
   *
   * @private
   */

  /**
   * If pointer-events none is not supported we inject a div into the DOM that blocks
   * all other click events. This property contains the reference to this element
   *
   * @private
   */

  /**
   * When the FlowManager is initially constructed it detects if we are using a browser
   * that does not support pointer-events. If it's not supported the fallback div is
   * created and injected into the DOM.
   */
  function FlowManager() {
    var _this;

    _this = _EventDispatcher.call(this) || this; // Fallback for IE10

    /* istanbul ignore if  */

    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "transitionOut", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "flowHijacked", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: Promise.resolve()
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "previousComponentId", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty((0, _assertThisInitialized2.default)(_this), "pointerDiv", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: void 0
    });

    if (bowser.msie && bowser.version <= 10) {
      _this.pointerDiv = document.createElement('div');

      _this.pointerDiv.classList.add('vueTransitionComponentPointerDiv');

      _this.pointerDiv.style.display = 'none';
      _this.pointerDiv.style.position = 'fixed';
      _this.pointerDiv.style.left = '0px';
      _this.pointerDiv.style.top = '0px';
      _this.pointerDiv.style.width = '100%';
      _this.pointerDiv.style.height = '100%';
      _this.pointerDiv.style.zIndex = '99999';
      document.body.appendChild(_this.pointerDiv);
    }

    return _this;
  }
  /**
   * When this method is called it will return a promise with a resolve method
   * that can be called to release the hijack. When the hijack is released the flow will continue.
   *
   * @public
   */


  var _proto = FlowManager.prototype;

  _proto.hijackFlow = function hijackFlow() {
    var _this2 = this;

    return new Promise(function (resolve) {
      _this2.flowHijacked = new Promise(function (release) {
        return resolve(release);
      });
    });
  };
  /**
   * When the flow is fully done this method should be called. For example when the
   * transition out of the current page is completely done. It will reset the transition
   * out promise, clear the previous component id and re-enable all the pointer events so
   * the user can navigate further.
   *
   * @public
   */


  _proto.done = function done() {
    this.transitionOut = null; // Reset the previous component id when the flow is done to allow re-opening of the same page after closing it

    this.previousComponentId = null; // Enable the pointer events and allow the flow

    this.enablePointerEvents();
  };
  /**
   * The vue router triggers the onLeave method twice, so we need to store the current componentId to
   * avoid weird page transition issues. If it's triggered on the same page we release the hijack right away.
   *
   * @public
   * @param {IAbstractPageTransitionComponent} pageInstance The reference to the current page instance
   * @param {(param?: (string | boolean)) => void} release The release method that will allow the vue-router to continue
   * @param {IRoute} to The target route we are navigating to
   * @param {IRoute} from The current route we are navigating away from
   */


  _proto.start = function start(pageInstance, release, to, from) {
    var _this3 = this;

    this.disablePointerEvents();

    if (this.previousComponentId === pageInstance.$options.name) {
      release();
    } else {
      this.previousComponentId = pageInstance.$options.name;
      this.dispatchEvent(new _FlowEvent.default(_FlowEvent.default.START, {
        to: to,
        from: from
      }));

      switch (pageInstance.flow) {
        case _FlowType.default.NORMAL:
          {
            this.transitionOut = pageInstance.transitionOut(true);
            this.transitionOut.then(function () {
              // Release the flow
              release(); // When the new path uses the same target component the onLeave will never be triggered on
              // the router view, therefore we mark it as done as soon as transition out is completed

              if (!_this3.isNewPageComponent(pageInstance, to)) {
                _this3.done();
              }
            });
            break;
          }

        case _FlowType.default.CROSS:
          {
            this.transitionOut = pageInstance.transitionOut(true);
            setTimeout(function () {
              return release();
            }, 0);
            break;
          }

        default:
          {
            throw new Error('[FlowManager] Unknown flow: [' + pageInstance.flow + ']');
          }
      }
    }
  };
  /**
   * During page navigation we want to disable all pointer events so the user
   * cannot navigate to another page while the current page switch is still running.
   * This causes major flow issues, might not be the prettiest solution but hey it works!
   *
   * @private
   */


  _proto.disablePointerEvents = function disablePointerEvents() {
    /* istanbul ignore if  */
    if (bowser.msie && bowser.version <= 10) {
      this.pointerDiv.style.display = 'block';
    } else {
      document.body.style.pointerEvents = 'none';
    }
  };
  /**
   * After the flow is completed the pointer events can be enabled again so the
   * user can continue navigating.
   *
   * @private
   */


  _proto.enablePointerEvents = function enablePointerEvents() {
    /* istanbul ignore if  */
    if (bowser.msie && bowser.version <= 10) {
      this.pointerDiv.style.display = 'none';
    } else {
      document.body.style.pointerEvents = 'all';
    }
  };
  /**
   * This method checks if the page we are navigating to is a new component. If the current component
   * shares the same name (for example: when using params to change content) it means it's not a new component and the
   * current component will never leave the DOM!
   *
   * @private
   * @param {IAbstractPageTransitionComponent} pageInstance The reference of the page that we are currently on
   * @param {IRoute} to The route we are about to navigate to
   * @returns {boolean} This indicates if the page we are going to is the same as the page we are currently on
   */


  _proto.isNewPageComponent = function isNewPageComponent(pageInstance, to) {
    return pageInstance.$options.name !== to.matched[0].components.default['name'];
  };
  /**
   * This method will probably never be called but if you want to you can dispose of
   * the flow manager and everything will be cleaned.
   *
   * @public
   */


  _proto.dispose = function dispose() {
    this.transitionOut = null;
    this.previousComponentId = null;
    /* istanbul ignore if  */

    if (this.pointerDiv !== undefined && document.body !== null) {
      document.body.removeChild(this.pointerDiv);
      this.pointerDiv = null;
    }

    _EventDispatcher.prototype.dispose.call(this);
  };

  return FlowManager;
}(_sengEvent.default);
/**
 * Create the single instance of the flow manager
 */


exports.FlowManager = FlowManager;
var flowManager = new FlowManager();
var _default = flowManager;
exports.default = _default;