"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _filter = _interopRequireDefault(require("lodash/filter"));

var IS_READY = 'isReady';
var _default = {
  name: 'AbstractRegistrableComponent',
  data: function data() {
    return {
      registrableComponents: []
    };
  },
  beforeCreate: function beforeCreate() {
    var _this = this;

    // This is used to detect if a component is registrable
    this.isRegistrable = true; // Root components do not contain a $vnode, so use the name as a fallback

    this.componentId = this.$vnode && this.$vnode.data.ref ? this.$vnode.data.ref : this.$options.name;
    this.registeredComponents = [];
    this.newRegisteredComponents = [];
    this.allComponentsReady = new Promise(function (resolve) {
      _this.allComponentsReadyResolveMethod = resolve;
    });
  },
  destroyed: function destroyed() {
    this.isRegistrable = null;

    if (this.registeredComponents) {
      this.registeredComponents.length = 0;
      this.registeredComponents = null;
    }

    if (this.newRegisteredComponents) {
      this.newRegisteredComponents.length = 0;
      this.newRegisteredComponents = null;
    }
  },
  methods: {
    isReady: function isReady() {
      // If you want to you can listen to the isReady event
      this.$emit(IS_READY, this); // Notify the parent about being ready

      if (this.$parent && this.$parent.componentReady) {
        this.$parent.componentReady(this);
      }
    },
    handleAllComponentsReady: function handleAllComponentsReady() {},
    updateRegistrableComponents: function updateRegistrableComponents(callback) {
      var _this2 = this;

      // Store the components before change
      var beforeChange = this.registrableComponents.map(function (child) {
        return child._uid;
      }); // Reset the array

      this.registeredComponents = []; // Create a new promise for notify'ing about the change

      this.asyncComponentsReady = new Promise(function (resolve) {
        _this2.allComponentsReadyResolveMethod = resolve;
      }); // Promised is used for doing async code in the component

      new Promise(function (resolve) {
        return callback(resolve);
      }).then(function () {
        // NOTE: Removed the $nextTick here because sometimes components do not have child components and therefore they
        // trigger the isReady method right away, breaking the flow!
        // Update the list of registrable components
        _this2.registrableComponents = (0, _filter.default)(_this2.$children, function (child) {
          return child.isRegistrable;
        }); // Find the new components after the change

        var afterChange = _this2.registrableComponents.map(function (child) {
          return child._uid;
        }); // Store the id's of the new components


        _this2.newRegisteredComponents = afterChange.filter(function (child) {
          return beforeChange.indexOf(child) === -1;
        }); // Restore the components that were not modified

        _this2.registeredComponents = afterChange.filter(function (child) {
          return beforeChange.indexOf(child) > -1;
        }); // There might be no change so trigger the resolve method right away!

        if ((0, _isEqual.default)(beforeChange, afterChange) || _this2.newRegisteredComponents.length === 0 && afterChange.length < beforeChange.length) {
          _this2.allComponentsReadyResolveMethod(_this2.newRegisteredComponents);
        }
      }); // Return the promise

      return this.asyncComponentsReady;
    },
    componentReady: function componentReady(component) {
      var _this3 = this;

      // Store the component id, so we can check if all are loaded
      this.registeredComponents.push(component._uid); // Check if we reached the total amount of transition components

      if (this.registrableComponents.length === this.registeredComponents.length && this.allComponentsReadyResolveMethod) {
        this.allComponentsReadyResolveMethod((0, _filter.default)(this.$children, function (child) {
          return _this3.newRegisteredComponents.indexOf(child._uid) > -1;
        }));
        this.newRegisteredComponents = [];
        this.allComponentsReadyResolveMethod = null;
      }
    },
    checkComponentsReady: function checkComponentsReady() {
      if (this.registrableComponents.length === 0) {
        this.allComponentsReadyResolveMethod();
      }
    }
  },
  mounted: function mounted() {
    var _this4 = this;

    // Update the array of registrable components
    this.registrableComponents = (0, _filter.default)(this.$children, function (child) {
      return child.isRegistrable;
    }); // On init everything is new

    this.newRegisteredComponents = this.registrableComponents.map(function (child) {
      return child._uid;
    }); // Wait for all components to be ready

    this.allComponentsReady.then(function () {
      return _this4.handleAllComponentsReady();
    }) // Add a timeout to allow error throwing in the promise chain!
    .catch(function (result) {
      /* istanbul ignore next */
      setTimeout(function () {
        throw result;
      });
    }); // We wait for the next tick otherwise the $children might not be set when you use a v-for loop

    this.$nextTick(function () {
      return _this4.checkComponentsReady();
    });
  }
};
exports.default = _default;